<!-- # CRUD Quiz
#
# Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.
#
# MVP Questions
#
# In our Property Tracker application:
# Q1. Where are we instantiating instances of the Property class?
# A1. Instances are instantiated in console.rb Class.new.
#
# Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
# A3. We are defining the SQL that enables us to save the ruby Property object into the database in the save function line 16 property.rb. Specifically when we call the save sql command on line 31.
# In our method we create a connection to our DB and save it in a variable.
# We save to a variable a sql command in a string.
# We execute that using the db method .exec before finally closing the connection.
# We close the connection - we don't want to leave it open.

# Q3. In console.rb, which lines modify the database?
# A3. each time property#.save is used in console.rb (lines 13, 22, 31). Also in Property.delete_all() at the start which cleans the decks at the start.
#
# Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
# A4. The database creates the id of a property object.

# Q5. Where and how do we assign the property id (that is generated by the database) to the ruby object?
# A5. In attr_reader :id.

# Q6. Why do we put a guard (an ‘if’ clause) on the @id attribute in the constructor?
# A6. To allow the database to create an id without error when it's not been created yet.

# Q7. Why are some of the CRUD actions represented by instance methods, and others, class methods?
# A7.
# Some actions are instance as they are object based. The obect has no knowledge of the rest of the class.
# Some other actions are class based. The class has knowledge of the whole.

# property3.save() INSTANCE METHOD
# property1.delete() INSTANCE METHOD
# all_the_properties = Property.all() CLASS METHOD
# hart_road = Property.find(property2.id) USING CLASS METHOD(QUERY INSTANCE) TO RETURN INSTANCE INFO
# carriers_road = Property.find_by_address("57 Carriers Road, CROESERW, SA13 7GQ") USING CLASS METHOD(QUERY INSTANCE) TO RETURN INSTANCE INFO


#create: this part refers to constructors and factory methods that 'create' new data objects for you to use, or add new records to a dabase.
# read: these are the getter methods in our code. Since one should never expose internal variables outside the class, we provide getters so other code can get information about the object's state. This is also reading the fields of various database entries.
# update: these are the setter methods, complimentary to the getters for instances where other code also needs to be able to modify the object or database entry.
# destroy: this refers to the object's destructor, the piece of code that frees up any allocated resources and ensures that the object can be disposed of cleanly, or that removes the record from the database.

# Q8. What type of data structure is returned by db.exec() and db.exec_prepared(), and how do we index into it to pull out a desired attribute?

# A8. The datastructure returned db.exec() is array of hashes (is the sql conmmand/query) and db.exec_prepared() is an array of properties initialised in the class (the values we wish to query), and we index into it with [0] /an array position and direct by using a class attribute/property to pull out a desired attribute.

#   SQL injections happen when a method accepts any form of input from the user without sanitising said input. To protect agains such attacks, we can use something called a prepared statement.
# A prepared statement is essentially an SQL query that has a 2 step execution, rather than one.

# First, we prepare a db.exec() statement and give it a name, which is essentially a string, and the SQL statement we want to execute. Instead of giving the values directly with the SQL statement, however, we only give it placeholders, indicating the number of values we want to insert in the SQL query.

# Once the statement is prepared, we want to execute db.exec_prepared() said prepared statement, this time providing the values too.

# This has a number of benefits:

# By sanitising the input, we defend against SQL injection attacks
# This also let's us add apostrophes in our text values (imagine what would happen to a value like 'Bob's Guitars' in a SQL query!)
# Plus once efficiency is a main concern, for mass updates/saves, a prepared statement is considerably faster.
# Luckily, the PG gem gives us an easy way of creating prepared statements!

# Q9. Why do we use prepared statements when performing database operations?
# A9. You should, in general, always prepare queries to be used multiple times. The result of preparing the query is a prepared statement, which can have placeholders (a.k.a. bind values) for parameters that you’ll provide when you execute the statement. This is much better than concatenating strings, for all the usual reasons (avoiding SQL injection attacks, for example).

# Extension Questions
# Look at the find_by_id and find_by_address methods in the Property class.

# Q10. What do they take in as their arguments?
# A10. arguments find_by_id array or find_by_address array. The arrays.

# Q11. What are their return values?
# A11. return values are Property.new(find_by_id array) Property.new(find_by_address array). The specific items. -->
